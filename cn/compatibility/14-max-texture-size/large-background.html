<!doctype html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>超大背景图接近 MAX_TEXTURE_SIZE</title>
  <link rel="stylesheet" href="styles.css">
  <style>
    .bg-area {
      position: relative;
      height: 640px;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid var(--border);
      background-repeat: no-repeat;
      background-position: center;
    }
    .bg-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      background-image:
        linear-gradient(0deg, rgba(0,0,0,0.12), rgba(0,0,0,0.12)),
        repeating-linear-gradient(90deg, rgba(255,255,255,0.08) 0, rgba(255,255,255,0.08) 1px, transparent 1px, transparent 40px),
        repeating-linear-gradient(0deg, rgba(255,255,255,0.08) 0, rgba(255,255,255,0.08) 1px, transparent 1px, transparent 40px);
    }
    .bg-label {
      position: absolute;
      top: 12px;
      left: 12px;
      padding: 8px 12px;
      background: rgba(15, 23, 42, 0.8);
      color: #e2e8f0;
      border-radius: 8px;
      font-size: 13px;
    }
  </style>
</head>
<body>
  <header class="topbar">
    <h1>超大背景图 | 接近 MAX_TEXTURE_SIZE</h1>
    <p>单张背景图（接近或超过上限）测试加载/光栅与合成层。拖动尺寸可尝试超限，观察失败模式。</p>
  </header>
  <main class="page">
    <section class="toolbar">
      <div class="group">
        <span class="chip">MAX_TEXTURE_SIZE <span id="max-size">检测中</span></span>
        <span class="chip">DPR <span id="dpr"></span></span>
      </div>
      <div class="group">
        <label>图像尺寸(px)</label>
        <input type="range" id="size" min="2048" max="8192" step="256" value="4096">
        <span id="size-label">4096</span>
      </div>
      <div class="group">
        <label>缩放</label>
        <input type="range" id="scale" min="0.25" max="2" step="0.05" value="1">
        <span id="scale-label">1.00</span>
      </div>
      <div class="group">
        <label>background-size</label>
        <select id="bg-size">
          <option value="contain">contain</option>
          <option value="cover" selected>cover</option>
          <option value="auto">auto</option>
        </select>
      </div>
      <div class="group">
        <label><input type="checkbox" id="repeat"> 重复平铺</label>
      </div>
      <button class="btn primary" id="regen">重新生成</button>
    </section>

    <section class="panel">
      <h2 class="section-title">测试区域</h2>
      <div class="meta-row">
        <span class="badge" id="status">等待生成...</span>
        <span class="badge mono" id="info">-</span>
      </div>
      <div class="bg-area" id="bg-area">
        <div class="bg-overlay"></div>
        <div class="bg-label" id="label">-</div>
      </div>
    </section>

    <section class="panel explain">
      <h3 class="section-title">使用说明</h3>
      <div>1）拖动尺寸到接近/超过 MAX_TEXTURE_SIZE，生成一次，观察加载时长帧、是否出现空白/降级。</div>
      <div>2）在 DevTools → Layers 观察背景层尺寸；Performance 录制首次出现大图时的长帧。</div>
      <div>3）滚动页面、调整 background-size/缩放，验证合成层是否平移而非重绘，是否出现撕裂或色偏。</div>
    </section>
  </main>

  <script>
    const maxSizeEl = document.getElementById("max-size");
    const dprEl = document.getElementById("dpr");
    const sizeInput = document.getElementById("size");
    const sizeLabel = document.getElementById("size-label");
    const scaleInput = document.getElementById("scale");
    const scaleLabel = document.getElementById("scale-label");
    const bgSizeSel = document.getElementById("bg-size");
    const repeatToggle = document.getElementById("repeat");
    const statusEl = document.getElementById("status");
    const infoEl = document.getElementById("info");
    const bgArea = document.getElementById("bg-area");
    const label = document.getElementById("label");
    let dirty = false;

    dprEl.textContent = (window.devicePixelRatio || 1).toFixed(2);

    function getMaxTextureSize() {
      const canvas = document.createElement("canvas");
      const gl = canvas.getContext("webgl");
      if (!gl) return "未知";
      return gl.getParameter(gl.MAX_TEXTURE_SIZE);
    }

    function createLargeImage(size) {
      const canvas = document.createElement("canvas");
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext("2d");
      const grd = ctx.createLinearGradient(0, 0, size, size);
      grd.addColorStop(0, "#0ea5e9");
      grd.addColorStop(1, "#a855f7");
      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, size, size);
      ctx.strokeStyle = "rgba(255,255,255,0.5)";
      const step = Math.max(32, size / 16);
      for (let i = 0; i < size; i += step) {
        ctx.beginPath();
        ctx.moveTo(i, 0);
        ctx.lineTo(i, size);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, i);
        ctx.lineTo(size, i);
        ctx.stroke();
      }
      ctx.fillStyle = "rgba(15,23,42,0.8)";
      ctx.font = `${Math.max(48, size / 32)}px 'Segoe UI'`;
      ctx.fillText(`${size}×${size}`, size * 0.1, size * 0.2);
      return canvas.toDataURL("image/png");
    }

    function applyBackground(dataUrl, size) {
      bgArea.style.backgroundImage = `url(${dataUrl})`;
      bgArea.style.backgroundSize = bgSizeSel.value;
      bgArea.style.backgroundRepeat = repeatToggle.checked ? "repeat" : "no-repeat";
      bgArea.style.transform = `scale(${Number(scaleInput.value)})`;
      label.textContent = `${size}px (${bgSizeSel.value})`;
      infoEl.textContent = `背景尺寸: ${size}×${size} ｜ repeat: ${repeatToggle.checked}`;
    }

    function markDirty() {
      dirty = true;
      statusEl.textContent = "参数已更改，点击重新生成";
    }

    function regenerate() {
      const size = Number(sizeInput.value);
      sizeLabel.textContent = size;
      const start = performance.now();
      statusEl.textContent = "生成中...";
      dirty = false;
      requestAnimationFrame(() => {
        const url = createLargeImage(size);
        applyBackground(url, size);
        const cost = performance.now() - start;
        statusEl.textContent = `生成完成 (${cost.toFixed(1)} ms)`;
      });
    }

    sizeInput.addEventListener("input", () => {
      sizeLabel.textContent = sizeInput.value;
      markDirty();
    });
    scaleInput.addEventListener("input", () => {
      scaleLabel.textContent = Number(scaleInput.value).toFixed(2);
      bgArea.style.transform = `scale(${Number(scaleInput.value)})`;
    });
    bgSizeSel.addEventListener("change", () => {
      markDirty();
    });
    repeatToggle.addEventListener("change", () => {
      markDirty();
    });
    document.getElementById("regen").addEventListener("click", regenerate);

    maxSizeEl.textContent = getMaxTextureSize();
    regenerate();
  </script>
</body>
</html>
