<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>test case10:Blend Mode Overlay Effects and Compositing Layers</title>
  <link rel="stylesheet" href="css/shared.css"/>
  <style>
    /* Page-specific micro styles (comments in English) */
    .swatch { width: 100%; height: 36px; border-radius: 6px; border: 1px solid var(--border); }
    .control { }
  </style>
</head>
<body>
  <header class="header">
    <div class="inner">
      <h1>test case10:Blend Mode Overlay Effects and Compositing Layers</h1>
      <p>verify Chrome right CSS <span class="code-like">mix-blend-mode</span> Rendering and compositing layer processing</p>
    </div>
  </header>

  <section class="section">
    <div class="toolbar" id="toolbar">
      <div class="control">
        <label>Blend Mode (mix-blend-mode)</label>
        <select id="mode">
          <option>normal</option>
          <option selected>multiply</option>
          <option>screen</option>
          <option>overlay</option>
          <option>darken</option>
          <option>lighten</option>
          <option>color-dodge</option>
          <option>color-burn</option>
          <option>hard-light</option>
          <option>soft-light</option>
          <option>difference</option>
          <option>exclusion</option>
          <option>hue</option>
          <option>saturation</option>
          <option>color</option>
          <option>luminosity</option>
        </select>
      </div>

      <div class="control">
        <label>Overlay color</label>
        <div class="inline">
          <input type="color" id="fgColor" value="#ff0000" title="Covering layer RGB color"/>
          <input type="range" id="fgAlpha" min="0" max="1" step="0.01" value="0.5" title="Alpha"/>
        </div>
        <div class="hint">Opacity:<span id="alphaLabel">0.50</span></div>
      </div>

      <div class="control">
        <label>Background color (blue area)</label>
        <input type="color" id="bgColor" value="#0000ff"/>
      </div>

      <div class="control">
        <label>Show white text</label>
        <div class="inline">
          <input type="checkbox" id="showText" checked/>
          <span class="hint">Observe the blending of text and background</span>
        </div>
      </div>

      <div class="control">
        <label>isolation(isolation)</label>
        <div class="inline">
          <input type="checkbox" id="isolate"/>
          <span class="hint">righttestZone enabled <span class="code-like">isolation: isolate</span></span>
        </div>
      </div>

      <div class="control">
        <label>Layer promotion tips</label>
        <select id="layerHint">
          <option value="none" selected>none</option>
          <option value="will">will-change: transform</option>
          <option value="z">transform: translateZ(0)</option>
        </select>
      </div>

      <div class="control">
        <label>Box size (width×high)</label>
        <div class="inline">
          <input type="number" id="boxW" value="320" min="60" max="1000" step="10"/>
          <input type="number" id="boxH" value="200" min="60" max="1000" step="10"/>
        </div>
      </div>

      <div class="control">
        <label>Location(left, top)</label>
        <div class="inline">
          <input type="number" id="boxL" value="30" min="-200" max="1000" step="1"/>
          <input type="number" id="boxT" value="20" min="-200" max="1000" step="1"/>
        </div>
        <div class="hint">Unit: percentage %(MutuallyrightAttestarea)</div>
      </div>

      <div class="control">
        <label>Expected mixed color (approximate)</label>
        <div class="swatch" id="swatch" title="Depending on the selected mode andcolorcalculate,Approximate values ​​only"></div>
        <div class="hint">Only implement multiply / screen official(sRGB,Simple Alpha).</div>
      </div>

      <div class="control">
        <label>operate</label>
        <div class="inline">
          <button id="reset">reset</button>
          <button id="random">Random parameters</button>
        </div>
      </div>

      <div class="control">
        <label>Browser support</label>
        <div class="hint"><span class="badge" id="support">Under detection</span></div>
      </div>
    </div>
  </section>

  <section class="section">
    <div class="stage-wrap">
      <div class="stage" id="stage">
        <div class="bg" id="bg"></div>
        <div class="blend-box" id="box" style="mix-blend-mode: multiply;">
          <div class="inner-text" id="boxText">Covering layer(<span id="modeLabel">multiply</span>)</div>
        </div>
      </div>
      <p class="small-note">hint:drag redCovering layeracross blueareaboundary,observable overlap(mix)not overlapped with(translucent overlay)part of the difference.</p>
    </div>
  </section>

  <section class="section">
    <div class="explain">
      <h3>illustrate</h3>
      <ol>
        <li><strong>Test objectives:</strong>verifydifferent <span class="code-like">mix-blend-mode</span> exist Chrome(based on Chromium)Whether the visual results in are as expected; observe whether the blending element triggers the creation of compositing layers to ensure performance during scrolling and animation.</li>
        <li><strong>How to use:</strong> Use the toolbar above to pick blend mode, color, and opacity, then drag the overlay position and size. Toggle "isolation" to test how <span class="code-like">isolation: isolate</span> affects blend boundaries.</li>
        <li><strong>Result check:</strong>Overlapping areas should show a blended color with a blue background (e.g. <em>multiply</em> tend to darken,<em>screen</em> Tend to brighten);Not overlappingareaanswerexistPage displayed on white backgroundtranslucent overlay;Edges should be smoothnoneflashing.</li>
        <li><strong>Composition layer observation:</strong>Open DevTools → Rendering → Check <em>Layer borders</em>.In general, use non- <span class="code-like">normal</span> Elements of the blending mode will become individually drawn/Candidates for synthesis. This page provides <span class="code-like">will-change</span> / 3D transform option to make it easier to observe layer boundaries.</li>
        <li><strong>Performance recommendations:</strong>A single mixed element is usually composed of GPU existsynthesis stagecalculate,rightLimited impact on frame rate.If pressure is neededtest,Please use thistestin the bag "Performance pressure" page.</li>
      </ol>
    </div>
  </section>

  <script>
    // Utility functions (comments in English as required)
    const $ = (sel) => document.querySelector(sel);
    const clamp = (v, min, max) => Math.min(max, Math.max(min, v));

    function hexToRgb(hex) {
      const s = hex.replace('#','');
      const bigint = parseInt(s, 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return [r,g,b];
    }
    function rgbToHex([r,g,b]) {
      return '#' + [r,g,b].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    // Basic sRGB multiply/screen with simple source-over alpha
    function channelMultiply(cb, cf, a) {
      const b = cb/255, f = cf/255;
      const blended = f * b;
      const out = (1 - a) * b + a * blended;
      return Math.round(out * 255);
    }
    function channelScreen(cb, cf, a) {
      const b = cb/255, f = cf/255;
      const blended = 1 - (1 - f) * (1 - b);
      const out = (1 - a) * b + a * blended;
      return Math.round(out * 255);
    }
    function computeSwatch(mode, fgHex, alpha, bgHex) {
      const fg = hexToRgb(fgHex);
      const bg = hexToRgb(bgHex);
      let out = [0,0,0];
      if (mode === 'multiply') {
        out = [channelMultiply(bg[0], fg[0], alpha), channelMultiply(bg[1], fg[1], alpha), channelMultiply(bg[2], fg[2], alpha)];
      } else if (mode === 'screen') {
        out = [channelScreen(bg[0], fg[0], alpha), channelScreen(bg[1], fg[1], alpha), channelScreen(bg[2], fg[2], alpha)];
      } else {
        out = null; // not implemented
      }
      return out ? rgbToHex(out) : null;
    }

    // Elements
    const mode = $('#mode');
    const fgColor = $('#fgColor');
    const fgAlpha = $('#fgAlpha');
    const bgColor = $('#bgColor');
    const showText = $('#showText');
    const isolate = $('#isolate');
    const layerHint = $('#layerHint');
    const box = $('#box');
    const bg = $('#bg');
    const boxText = $('#boxText');
    const modeLabel = $('#modeLabel');
    const alphaLabel = $('#alphaLabel');
    const swatch = $('#swatch');
    const boxW = $('#boxW');
    const boxH = $('#boxH');
    const boxL = $('#boxL');
    const boxT = $('#boxT');
    const resetBtn = $('#reset');
    const randomBtn = $('#random');
    const stage = $('#stage');
    const support = $('#support');

    function apply() {
      // Update blend mode
      box.style.mixBlendMode = mode.value;
      modeLabel.textContent = mode.value;

      // Colors
      const a = +fgAlpha.value;
      const [r,g,b_] = hexToRgb(fgColor.value);
      box.style.background = `rgba(${r}, ${g}, ${b_}, ${a})`;
      alphaLabel.textContent = a.toFixed(2);
      bg.style.background = bgColor.value;

      // Text visibility
      boxText.style.display = showText.checked ? 'block' : 'none';

      // Isolation on stage
      stage.style.isolation = isolate.checked ? 'isolate' : 'auto';

      // "Layer" hints
      box.style.willChange = 'auto';
      box.style.transform = 'none';
      if (layerHint.value === 'will') {
        box.style.willChange = 'transform';
      } else if (layerHint.value === 'z') {
        box.style.transform = 'translateZ(0)';
      }

      // Size
      box.style.width = boxW.value + 'px';
      box.style.height = boxH.value + 'px';
      // Position in percentage of stage
      const lPerc = +boxL.value;
      const tPerc = +boxT.value;
      const left = stage.clientWidth * lPerc / 100;
      const top = stage.clientHeight * tPerc / 100;
      box.style.left = left + 'px';
      box.style.top = top + 'px';

      // Swatch computation
      const approx = computeSwatch(mode.value, fgColor.value, a, bgColor.value);
      swatch.style.background = approx ? approx : 'repeating-conic-gradient(#ddd 0% 25%, #eee 0% 50%) 50% / 12px 12px';
      swatch.title = approx
        ? `Approximate blended color: ${approx}`
        : 'No calculation for this mode; visual comparison only';
    }

    // Drag support (to observe boundary crossing)
    let dragging = false;
    let startX = 0, startY = 0, startLeft = 0, startTop = 0;
    box.addEventListener('pointerdown', (e)=>{
      dragging = true;
      box.setPointerCapture(e.pointerId);
      box.classList.add('dragging');
      startX = e.clientX;
      startY = e.clientY;
      startLeft = parseFloat(box.style.left || '0');
      startTop = parseFloat(box.style.top || '0');
    });
    box.addEventListener('pointermove', (e)=>{
      if (!dragging) return;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      const newLeft = clamp(startLeft + dx, -400, stage.clientWidth + 200);
      const newTop = clamp(startTop + dy, -300, stage.clientHeight + 200);
      box.style.left = newLeft + 'px';
      box.style.top = newTop + 'px';
    });
    function endDrag(e){
      if (!dragging) return;
      dragging = false;
      box.releasePointerCapture(e.pointerId);
      box.classList.remove('dragging');
      // update number inputs based on final position
      const lPerc = (parseFloat(box.style.left) / stage.clientWidth) * 100;
      const tPerc = (parseFloat(box.style.top) / stage.clientHeight) * 100;
      boxL.value = Math.round(lPerc);
      boxT.value = Math.round(tPerc);
    }
    box.addEventListener('pointerup', endDrag);
    box.addEventListener('pointercancel', endDrag);
    window.addEventListener('resize', apply);

    // Bind events
    [mode, fgColor, fgAlpha, bgColor, showText, isolate, layerHint, boxW, boxH, boxL, boxT].forEach(el=>{
      el.addEventListener('input', apply);
      el.addEventListener('change', apply);
    });

    // Reset and random
    resetBtn.addEventListener('click', ()=>{
      mode.value = 'multiply';
      fgColor.value = '#ff0000';
      fgAlpha.value = 0.5;
      bgColor.value = '#0000ff';
      showText.checked = true;
      isolate.checked = false;
      layerHint.value = 'none';
      boxW.value = 320; boxH.value = 200;
      boxL.value = 30; boxT.value = 20;
      apply();
    });
    randomBtn.addEventListener('click', ()=>{
      const modes = Array.from(mode.options).map(o=>o.value);
      mode.value = modes[Math.floor(Math.random()*modes.length)];
      fgColor.value = '#'+Math.floor(Math.random()*0xffffff).toString(16).padStart(6,'0');
      bgColor.value = '#'+Math.floor(Math.random()*0xffffff).toString(16).padStart(6,'0');
      fgAlpha.value = (Math.random()*0.8 + 0.1).toFixed(2);
      boxW.value = Math.floor(Math.random()*400)+120;
      boxH.value = Math.floor(Math.random()*300)+120;
      boxL.value = Math.floor(Math.random()*80);
      boxT.value = Math.floor(Math.random()*60);
      [showText, isolate].forEach(el=>{ el.checked = Math.random() > 0.3; });
      const hints = ['none','will','z'];
      layerHint.value = hints[Math.floor(Math.random()*hints.length)];
      apply();
    });

    // Feature support indicator
    const blendSupported = CSS.supports('mix-blend-mode', 'multiply');
    support.textContent = blendSupported ? 'support mix-blend-mode' : 'Nosupport(Canablenoneeffect)';
    support.classList.add(blendSupported ? 'good' : 'bad');

    // Initial paint
    apply();
  </script>
</body>
</html>
